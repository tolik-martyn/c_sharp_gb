//Это библитоека методов (чтобы в дальнейшем обращаться к методам). Актуально, когда рабочий и текущий файл находятся в одной рабочей папке (чтобы библиотека была не на стороннем сервисе). 

// К библиотеке подключаемся через "using <namespace>". Делаем это из файла, в который нужно передать метод из текущей библиотеки/<namespace>. Пример заполнения: <using LibraryHelp;>.
// Но если мы напрямую обращаемся к методу через "namespace.class.<название метода, который вызываем>", то в рабочем файле мы не указываем "using <namespace>" (<using LibraryHelp;>).
// Если бы <namespace> при вызове метода не указывали, то тогда обязательно для подключения к библиотеке нужно указывать "using <namespace>" (<using LibraryHelp;>).

// Для обращения к библиотеке с вызовом метода нужно выполнить: <LibraryHelp.Methods.Help> ("namespace.class.<название метода, который вызываем>").

// В текущем файле перед  названием метода обязательно указываем <public static> (пример: <public static void Help()>). 
// <public> - по умолчанию всё считается приватным, если не указано другое. Поэтому мы делает метод публичным через <public>.
// <static> - делает метод постоянным. Теперь этот метод существует не зависимо от экземпляров объекта (существует в единственном виде для всех, и все другие о нем знают).

namespace LibraryHelp
{
    class Methods
    {
        #region Fill&Print

        public static void FillArray(int[] numbers, int minValue = 0, int maxValue = 100) // метод для заполнения массива целыми числами. =>
        // => <minValue = 0, int maxValue = 100> - так мы указываем значения по умолчанию от <0> до <100>. =>
        // => Если при вызове метода <FillArray> не указываать <minValue>, <maxValue>, то ошибки не будет (так как подставятся значения по умолчанию). 
        {
            maxValue++;
            Random random = new Random();
            for (int i = 0; i < numbers.Length; i++)
            {
                numbers[i] = random.Next(minValue, maxValue);
            }
        }

        //----------------------------------------------------------------------------------------------------

        public static void FillArray(double[] numbers, int minValue = 0, int maxValue = 100, int roundNum = 2) // метод для заполнения =>
        // => массива вещественными (дробными) числами. <roundNum> - разряд, до которого округляем ("1" - до десятых, "2" - до сотых и т.д.). 
        {
            maxValue++;
            Random random = new Random();
            for (int i = 0; i < numbers.Length; i++)
            {
                numbers[i] = Math.Round((random.Next(minValue, maxValue) * random.NextDouble()), roundNum); // <Math.Round();> - если указать => 
                // => один параметр, то дробная часть округлится полностью. Второй параметр отвечает за то, до какого знака после запятой округляем.
                // numbers[i] = random.NextDouble() * 20 - 10; // это другой вариант вывода вещественных чисел. => 
                // => <random.NextDouble() * 20 - 10;> - второй вариант. Даст нам вещественные числа в диапазоне от "-10" до "10" (не включительно). => 
                // => сначала при умножении на "20" получаем диапазон от 0 до 20. Далее за счет "-10" диапазон меняется на "-10" до "10".

            }
        }

        //----------------------------------------------------------------------------------------------------

        public static void FillArray(int[,] matrix, int minValue = 0, int maxValue = 100) // метод заполнения двумерного массива случайными числами. 
        {
            maxValue++;
            Random random = new Random();

            for (int i = 0; i < matrix.GetLength(0); i++)
            {
                for (int j = 0; j < matrix.GetLength(1); j++)
                {
                    matrix[i, j] = random.Next(minValue, maxValue);
                }
            }
        }

        //----------------------------------------------------------------------------------------------------

        public static void PrintArray(int[] numbers) // метод для печати массива, который заполнен целыми числами. 
        {
            Console.WriteLine("Вывод массива: ");
            for (int i = 0; i < numbers.Length; i++)
            {
                Console.Write(numbers[i] + "  ");
            }
            Console.WriteLine();
        }

        //----------------------------------------------------------------------------------------------------

        public static void PrintArray(double[] numbers) // метод для печати массива, который заполнен вещественными (дробными) числами.
        {
            Console.WriteLine("Вывод массива: ");
            for (int i = 0; i < numbers.Length; i++)
            {
                Console.Write(numbers[i] + "  ");
            }
            Console.WriteLine();
        }

        //----------------------------------------------------------------------------------------------------

        public static void PrintArray(int[,] matrix) // метод печати двумерного массива. 
        {
            for (int i = 0; i < matrix.GetLength(0); i++) // <matrix.GetLength(0)> - показывает количество строк (в нашем случае это "3", так как <[3, 4]>). =>
                                                          // => Сначала указываем имя массива <matrix>, далее через точку оператор <GetLength()>. "(0)" - означает количество строк.
            {
                for (int j = 0; j < matrix.GetLength(1); j++) // <matrix.GetLength(1)> - показывает количество столбцов (в нашем случае это "4", так как <[3, 4]>). =>
                                                              // => "(1)" - означает количество столбцов.
                {
                    Console.Write($"{matrix[i, j]} ");
                }
                Console.WriteLine();
            }
        }

        #endregion

        public static void ReverseArray(int[] numbers) // метод для разворота одномерного массива.
        {
            int maxIndex = numbers.Length - 1; // <maxIndex> - это максимальный индекс. Он равен значению длины массива минус 1.  

            for (int i = 0; i < numbers.Length / 2; i++) // <numbers.Length / 2> - делим размер массива пополам, чтобы цикл закончился сразу после разворота масива. 
            {
                // int temporary = numbers[i]; // временная переменная, через которую мы будем менять значения индексов массива. 
                // numbers[i] = numbers[maxIndex - i]; // <maxIndex - i> - значение нужно, чтобы перебирать массив с конца. 
                // numbers[maxIndex - i] = temporary;
                (numbers[i], numbers[maxIndex - i]) = (numbers[maxIndex - i], numbers[i]); // такие записи в скобках называются "кортежи". Картеж это набор =>
                // => элементов (набор данных). Через кортежи удобно менять переменные местами (не нужно создавать дополнительную переменную). Картежу =>
                // => можно присвоить значения картежа (например, поменяв переменные местами, как в нашем случае). 
            }
        }

        //----------------------------------------------------------------------------------------------------



        //----------------------------------------------------------------------------------------------------



        //----------------------------------------------------------------------------------------------------



        //----------------------------------------------------------------------------------------------------

    }
}
